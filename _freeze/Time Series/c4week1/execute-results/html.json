{
  "hash": "2b06e077ff14f095aa773fe8f6f69c7e",
  "result": {
    "engine": "jupyter",
    "markdown": "---\ntitle: \"W1:Sequences and Prediction\"\nexecute:\n  warning: false\n  error: false\nformat:\n  html:\n    toc: true\n    toc-location: right\n    code-fold: show\n    code-tools: true\n    number-sections: true\n    code-block-bg: true\n    code-block-border-left: \"#31BAE9\"\n---\n\nWeek 1 Sequences and Prediction\n\nHi Learners and welcome to this course on sequences and prediction! In this course we'll take a look at some of the unique considerations involved when handling sequential time series data -- where values change over time, like the temperature on a particular day, or the number of visitors to your web site. We'll discuss various methodologies for predicting future values in these time series, building on what you've learned in previous courses!\n\nwhat exactly is a time series?\n\nIt's typically defined as an ordered sequence of values that are usually equally spaced over time\n\n::: {#c2eee468 .cell execution_count=1}\n``` {.python .cell-code}\nimport tensorflow as tf\nimport numpy as np\nimport matplotlib.pyplot as plt\n```\n:::\n\n\n# Fixed partitioning\n\n![](images/clipboard-3451250041.png){width=\"600\"}\n\n# Roll forward partitioning\n\n![](images/clipboard-1393300349.png){width=\"600\"}\n\n# Metrics\n\n![](images/clipboard-3633449115.png){width=\"600\"}\n\n# moving average\n\n![](images/clipboard-3121756726.png)\n\n![](images/clipboard-500670191.png)\n\n\n\n# Plot Utilities\n\n::: {#7628b249 .cell execution_count=2}\n``` {.python .cell-code}\ndef plot_series(time, series, format=\"-\", start=0, end=None):\n    \"\"\"\n    Visualizes time series data\n\n    Args:\n      time (array of int) - contains the time steps\n      series (array of int) - contains the measurements for each time step\n      format - line style when plotting the graph\n      label - tag for the line\n      start - first time step to plot\n      end - last time step to plot\n    \"\"\"\n\n    # Setup dimensions of the graph figure\n    plt.figure(figsize=(10, 6))\n    \n    if type(series) is tuple:\n\n      for series_num in series:\n        # Plot the time series data\n        plt.plot(time[start:end], series_num[start:end], format)\n\n    else:\n      # Plot the time series data\n      plt.plot(time[start:end], series[start:end], format)\n\n    # Label the x-axis\n    plt.xlabel(\"Time\")\n\n    # Label the y-axis\n    plt.ylabel(\"Value\")\n\n    # Overlay a grid on the graph\n    plt.grid(True)\n\n    # Draw the graph on screen\n    plt.show()\n```\n:::\n\n\n# functions to generate your synthetic data\n\n::: {#eaa08850 .cell execution_count=3}\n``` {.python .cell-code}\ndef trend(time, slope=0):\n    \"\"\"\n    Generates synthetic data that follows a straight line given a slope value.\n\n    Args:\n      time (array of int) - contains the time steps\n      slope (float) - determines the direction and steepness of the line\n\n    Returns:\n      series (array of float) - measurements that follow a straight line\n    \"\"\"\n\n    # Compute the linear series given the slope\n    series = slope * time\n\n    return series\n\ndef seasonal_pattern(season_time):\n    \"\"\"\n    Just an arbitrary pattern, you can change it if you wish\n    \n    Args:\n      season_time (array of float) - contains the measurements per time step\n\n    Returns:\n      data_pattern (array of float) -  contains revised measurement values according \n                                  to the defined pattern\n    \"\"\"\n\n    # Generate the values using an arbitrary pattern\n    data_pattern = np.where(season_time < 0.4,\n                    np.cos(season_time * 2 * np.pi),\n                    1 / np.exp(3 * season_time))\n    \n    return data_pattern\n\ndef seasonality(time, period, amplitude=1, phase=0):\n    \"\"\"\n    Repeats the same pattern at each period\n\n    Args:\n      time (array of int) - contains the time steps\n      period (int) - number of time steps before the pattern repeats\n      amplitude (int) - peak measured value in a period\n      phase (int) - number of time steps to shift the measured values\n\n    Returns:\n      data_pattern (array of float) - seasonal data scaled by the defined amplitude\n    \"\"\"\n    \n    # Define the measured values per period\n    season_time = ((time + phase) % period) / period\n\n    # Generates the seasonal data scaled by the defined amplitude\n    data_pattern = amplitude * seasonal_pattern(season_time)\n\n    return data_pattern\n\ndef noise(time, noise_level=1, seed=None):\n    \"\"\"Generates a normally distributed noisy signal\n\n    Args:\n      time (array of int) - contains the time steps\n      noise_level (float) - scaling factor for the generated signal\n      seed (int) - number generator seed for repeatability\n\n    Returns:\n      noise (array of float) - the noisy signal\n    \"\"\"\n\n    # Initialize the random number generator\n    rnd = np.random.RandomState(seed)\n\n    # Generate a random number for each time step and scale by the noise level\n    noise = rnd.randn(len(time)) * noise_level\n    \n    return noise\n```\n:::\n\n\n# Generate the synthetic data\n\n::: {#1b045ccb .cell execution_count=4}\n``` {.python .cell-code}\n# Parameters\ntime = np.arange(4 * 365 + 1, dtype=\"float32\")\nbaseline = 10\namplitude = 40\nslope = 0.05\nnoise_level = 5\n\n\nprint(len(time))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n1461\n```\n:::\n:::\n\n\n::: {#acd6e738 .cell execution_count=5}\n``` {.python .cell-code}\n# Create the series\nseries = baseline + trend(time, slope) + seasonality(time, period=365, amplitude=amplitude)\n\n# Update with noise\nseries = series+noise(time, noise_level, seed=42)\n\n# Plot the results\nplot_series(time, series)\n```\n\n::: {.cell-output .cell-output-display}\n![](c4week1_files/figure-html/cell-6-output-1.png){width=819 height=503}\n:::\n:::\n\n\n# Split the Dataset\n\n::: {#ad84b574 .cell execution_count=6}\n``` {.python .cell-code}\n# Define the split time\nsplit_time = 1000\n\n# Get the train set \ntime_train = time[:split_time]\nx_train = series[:split_time]\n\n# Get the validation set\ntime_valid = time[split_time:]\nx_valid = series[split_time:]\n```\n:::\n\n\n1 to 1000 for training\n\n::: {#c71e684b .cell execution_count=7}\n``` {.python .cell-code}\n# Plot the train set\nplot_series(time_train, x_train)\n```\n\n::: {.cell-output .cell-output-display}\n![](c4week1_files/figure-html/cell-8-output-1.png){width=819 height=503}\n:::\n:::\n\n\n1000 to 1400 for valid\n\n::: {#75b3efe0 .cell execution_count=8}\n``` {.python .cell-code}\n# Plot the validation set\nplot_series(time_valid, x_valid)\n```\n\n::: {.cell-output .cell-output-display}\n![](c4week1_files/figure-html/cell-9-output-1.png){width=816 height=503}\n:::\n:::\n\n\n# Naive Forecast\n\n::: {#231dc05c .cell execution_count=9}\n``` {.python .cell-code}\nnaive_forecast = series[split_time - 1:-1]\n\n# Define time step\ntime_step = 100\n\n# Print values\nprint(f'ground truth at time step {time_step}: {x_valid[time_step]}')\nprint(f'prediction at time step {time_step + 1}: {naive_forecast[time_step + 1]}')\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nground truth at time step 100: 109.84197926023576\nprediction at time step 101: 109.84197926023576\n```\n:::\n:::\n\n\n::: {#265e546b .cell execution_count=10}\n``` {.python .cell-code}\n# Plot the results\nplot_series(time_valid, (x_valid, naive_forecast))\n```\n\n::: {.cell-output .cell-output-display}\n![](c4week1_files/figure-html/cell-11-output-1.png){width=816 height=503}\n:::\n:::\n\n\n::: {#dfa39c49 .cell execution_count=11}\n``` {.python .cell-code}\n# Zooming in\nplot_series(time_valid, (x_valid, naive_forecast), start=0, end=150)\n```\n\n::: {.cell-output .cell-output-display}\n![](c4week1_files/figure-html/cell-12-output-1.png){width=816 height=503}\n:::\n:::\n\n\nComputing Metrics\n\nmean_squared_error:\n\n::: {#92a47bb7 .cell execution_count=12}\n``` {.python .cell-code}\nprint(tf.keras.metrics.mean_squared_error(x_valid, naive_forecast).numpy())\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n61.8275342640202\n```\n:::\n:::\n\n\nmean_absolute_error:\n\n::: {#d5ff82ca .cell execution_count=13}\n``` {.python .cell-code}\nprint(tf.keras.metrics.mean_absolute_error(x_valid, naive_forecast).numpy())\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n5.9379084434271485\n```\n:::\n:::\n\n\n# Moving Average\n\n::: {#83b4daba .cell execution_count=14}\n``` {.python .cell-code}\ndef moving_average_forecast(series, window_size):\n    \"\"\"Generates a moving average forecast\n\n    Args:\n      series (array of float) - contains the values of the time series\n      window_size (int) - the number of time steps to compute the average for\n\n    Returns:\n      forecast (array of float) - the moving average forecast\n    \"\"\"\n\n    # Initialize a list\n    forecast = []\n    \n    # Compute the moving average based on the window size\n    for time in range(len(series) - window_size):\n      forecast.append(series[time:time + window_size].mean())\n    \n    # Convert to a numpy array\n    forecast = np.array(forecast)\n\n    return forecast\n```\n:::\n\n\nusing past 30 day moving average\n\n::: {#2fdd8530 .cell execution_count=15}\n``` {.python .cell-code}\n# Generate the moving average forecast\nmoving_avg = moving_average_forecast(series, 30)[split_time - 30:]\n\n# Plot the results\nplot_series(time_valid, (x_valid, moving_avg))\n```\n\n::: {.cell-output .cell-output-display}\n![](c4week1_files/figure-html/cell-16-output-1.png){width=816 height=503}\n:::\n:::\n\n\n::: {#1944f056 .cell execution_count=16}\n``` {.python .cell-code}\n# Compute the metrics\nprint(tf.keras.metrics.mean_squared_error(x_valid, moving_avg).numpy())\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n106.67456927078204\n```\n:::\n:::\n\n\n::: {#2a567456 .cell execution_count=17}\n``` {.python .cell-code}\nprint(tf.keras.metrics.mean_absolute_error(x_valid, moving_avg).numpy())\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n7.142418746782468\n```\n:::\n:::\n\n\n# Differencing\n\n365 days Differencing\n\n::: {#16271288 .cell execution_count=18}\n``` {.python .cell-code}\n# Subtract the values at t-365 from original series\ndiff_series = (series[365:] - series[:-365])\n\n# Truncate the first 365 time steps\ndiff_time = time[365:]\n\n# Plot the results\nplot_series(diff_time, diff_series)\n```\n\n::: {.cell-output .cell-output-display}\n![](c4week1_files/figure-html/cell-19-output-1.png){width=819 height=503}\n:::\n:::\n\n\n::: {#f3b426a9 .cell execution_count=19}\n``` {.python .cell-code}\n# Generate moving average from the time differenced dataset\ndiff_moving_avg = moving_average_forecast(diff_series, 30)\n\n# Slice the prediction points that corresponds to the validation set time steps\ndiff_moving_avg = diff_moving_avg[split_time - 365 - 30:]\n\n# Slice the ground truth points that corresponds to the validation set time steps\ndiff_series = diff_series[split_time - 365:]\n\n# Plot the results\nplot_series(time_valid, (diff_series, diff_moving_avg))\n```\n\n::: {.cell-output .cell-output-display}\n![](c4week1_files/figure-html/cell-20-output-1.png){width=808 height=503}\n:::\n:::\n\n\nadd back Differencing\n\n::: {#e2475e5d .cell execution_count=20}\n``` {.python .cell-code}\n# Add the trend and seasonality from the original series\ndiff_moving_avg_plus_past = series[split_time - 365:-365] + diff_moving_avg\n\n# Plot the results\nplot_series(time_valid, (x_valid, diff_moving_avg_plus_past))\n```\n\n::: {.cell-output .cell-output-display}\n![](c4week1_files/figure-html/cell-21-output-1.png){width=816 height=503}\n:::\n:::\n\n\n::: {#db33be5f .cell execution_count=21}\n``` {.python .cell-code}\n# Compute the metrics\nprint(tf.keras.metrics.mean_squared_error(x_valid, diff_moving_avg_plus_past).numpy())\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n53.76458170166675\n```\n:::\n:::\n\n\n::: {#285df04e .cell execution_count=22}\n``` {.python .cell-code}\nprint(tf.keras.metrics.mean_absolute_error(x_valid, diff_moving_avg_plus_past).numpy())\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n5.903241526511199\n```\n:::\n:::\n\n\n# Smoothing\n\nmoving average with 11 days after remove referencing\n\n::: {#66b46af2 .cell execution_count=23}\n``` {.python .cell-code}\n# Smooth the original series before adding the time differenced moving average\ndiff_moving_avg_plus_smooth_past = moving_average_forecast(series[split_time - 370:-359], 11) + diff_moving_avg\n\n# Plot the results\nplot_series(time_valid, (x_valid, diff_moving_avg_plus_smooth_past))\n```\n\n::: {.cell-output .cell-output-display}\n![](c4week1_files/figure-html/cell-24-output-1.png){width=816 height=503}\n:::\n:::\n\n\n::: {#94475cab .cell execution_count=24}\n``` {.python .cell-code}\n # Compute the metrics\nprint(tf.keras.metrics.mean_squared_error(x_valid, diff_moving_avg_plus_smooth_past).numpy())\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n34.3157226871993\n```\n:::\n:::\n\n\n::: {#6bfc0b6d .cell execution_count=25}\n``` {.python .cell-code}\nprint(tf.keras.metrics.mean_absolute_error(x_valid, diff_moving_avg_plus_smooth_past).numpy())\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n4.605328954146046\n```\n:::\n:::\n\n\n# resource:\n\n\n\nhttps://www.coursera.org/learn/tensorflow-sequences-time-series-and-prediction\n\nhttps://github.com/https-deeplearning-ai/tensorflow-1-public/tree/main/C4\n\n",
    "supporting": [
      "c4week1_files"
    ],
    "filters": [],
    "includes": {}
  }
}